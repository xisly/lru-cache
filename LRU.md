# Тестовое задание на позицию go-разработчик

## Разработка кеширующего сервиса

Реализовать сервис, предоставляющий возможность кешировать данные по стратегии LRU. Использовать сторонние хранилища не нужно. Данные должны храниться в оперативной памяти процесса (подробности ниже).

## Требования к сервису

### Хранилище

1. Кэш использует `LRU eviction policy` (https://www.geeksforgeeks.org/cache-eviction-policies-system-design/)
2. Структура, отвечающая за хранение данных имплементирует интерфейс:
```go
// ILRUCache интерфейс LRU-кэша. Поддерживает только строковые ключи. Поддерживает только простые типы данных в значениях. 
type ILRUCache interface {
	// Put запись данных в кэш
	Put(ctx context.Context, key string, value interface{}, ttl time.Duration) error
    // Get получение данных из кэша по ключу
	Get(ctx context.Context, key string) (value interface{}, expiresAt time.Time, err error)
    // GetAll получение всего наполнения кэша в виде двух слайсов: слайса ключей и слайса значений. Пары ключ-значения из кэша располагаются на соответствующих позициях в слайсах.
	GetAll(ctx context.Context) (keys []string, values []interface{}, err error)
    // Evict ручное удаление данных по ключу
    Evict(ctx context.Context, key string) (value interface{}, err error)
    // EvictAll ручная инвалидация всего кэша
	EvictAll(ctx context.Context) error
}
```
3. Реализация должна быть потокобезопасной. Выбор стратегии обеспечения потокобезопасности остается на усмотрение разработчика. 
4. Требуемая алгоритмическая сложность по времени:
    - `Put` - `O(1)`
    - `Get` - `O(1)`
    - `GetAll` - `O(n)`
    - `Evict` - `O(1)`
    - `EvictAll` - `O(1)`
5. Пространственная сложность не регламентируется и может быть любой
6. При добавлении данных в кеш есть возможность указать TTL. Если TTL равен 0, накладывается TTL по умолчанию. 
7. TTL обновляется при вызове `Put` для уже существующего ключа. 
8. `Get` не влияет на TTL
9. Запрещается использовать готовые библиотечные реализации LRU-кэша. Хранилище должно быть реализовано с нуля.
10. Данные хранятся в оперативной памяти сервиса (нет необходимости дампить кэш в файловую систему)

### Публичный HTTP API

Для реализации API рекомендуем использовать `chi`.

Каких-либо гарантий относительно корректности входных данных нет. Вся валидация остается на стороне сервиса. Допустимое поведение хранилища описано в интерфейсе `ILRUCache`. 

Все обработчики также должны возвращать `500` на любую возникшую необработанную ошибку.

#### Обработчик `POST /api/lru`

Добавление данных в кэш. 

Примеры запросов:
1. Запрос с указанием TTL в секундах и строковым значением
    ```
    POST /api/lru HTTP/1.1
    Content-Type: application/json
    ...
    
    {
        "key": "some_key",
        "value": "some_cached_value",
        "ttl_seconds": 30
    }
    ```
2. Запрос без указания TTL и с числовым значением
    ```
    POST /api/lru HTTP/1.1
    Content-Type: application/json
    ...
    
    {
        "key": "some_key",
        "value": 331.1
    }
    ```
   
Возможные коды ответа:
1. `201` - данные записаны в кэш
2. `400` - невалидные входные данные

#### Обработчик `GET /api/lru/{key}`

Получение данных по ключу

Пример запроса:

```
GET /api/lru/some_key HTTP/1.1
Content-Length: 0
```

Возможные ответы сервера: 
1. `200` - Данные получены
   ```
   200 OK HTTP/1.1
   Content-Type: application/json
   ...

    {
        "key": "some_key",
        "value": 311.1,
        "expires_at": 1718278493
    }
   ```
2. `404` - ключ не найден

#### Обработчик `GET /api/lru`

Получение всего текущего наполнения кэша в виде двух списков: списка ключей и списка значений. Пары ключ-значение располагаются на соответствующих индексах. Других ограничений на порядок нет.

Возможные ответы сервера:
1. `200`
    ```
   200 OK HTTP/1.1
   Content-Type: application/json
   ...

    {
        "keys": ["some_key3", "some_key1", "some_key2"],
        "values": ["some_value3", 1.1, "some_value2"]
    }
   ```
2. `204` - кэш пустой

#### Обработчик `DELETE /api/lru/{key}`

Удаление пары ключ/значение 

Пример запроса:

```
DELETE /api/lru/some_key HTTP/1.1
Content-Length: 0
```

Возможные ответы сервера:
1. `204` - успешное удаление
2. `404` - ключ не найден

#### Обработчик `DELETE /api/lru`

Полная очистка кэша. 

Пример запроса:

```
DELETE /api/lru HTTP/1.1
Content-Length: 0
```

Возможные ответы сервера:
1. `204` - успешное удаление

### Конфигурирование

1. Сервис поддерживает следующие параметры конфигурации:
    - `server_host_port`: конфигурируется через переменную окружения `SERVER_HOST_PORT` или через флаг `-server-host-port`, по умолчанию равен `localhost:8080`
    - `cache_size`: конфигурируется через переменную окружения `CACHE_SIZE` или флаг `-cache-size`, по умолчанию равен `10`
    - `default_cache_ttl`: конфигурируется через переменную окружения `DEFAULT_CACHE_TTL` или флаг `-default-cache-ttl`, по умолчанию равен `1 минуте`
    - `log_level`: конфигурируется через переменную окружения `LOG_LEVEL` или флаг `-log-level`, по умолчанию выставляется в `WARN`
2. Политика конфигурирования (общая для всех параметров):
    - Если для параметра определен флаг запуска, используется он
    - Если флаг не определен, используется переменная окружения
    - Если не определены ни флаг, ни переменная окружения, используется значение по умолчанию
3. Для работы с переменными окружения рекомендуем использовать https://github.com/caarlos0/env
4. Для работы с флагами рекомендуем использовать пакет `flag` стандартной библиотеки

### Логирование

1. Сервис пишет логи
2. Логи разделяются по уровням логирования
3. Выбор библиотеки для логирования остается на усмотрение разработчика
4. Формат логирования остается на усмотрение разработчика
5. Логи содержат:
    1. Уровень логирования
    2. Временную метку события
    3. Логируемое сообщение
    4. Другие поля на усмотрение разработчика
6. Сервис логирует все входящие запросы:
    1. На уровне `DEBUG`
    2. С указанием обработчика
    3. С указанием времени, затраченного на обработку запроса

### Документирование

1. Все экспортируемые объекты во всех пакетах должны содержать комментарии в формате `godoc`.
2. Все пакеты должны содержать описания в формате `godoc`.

### Тестирование

1. Покрытие кода тестами должно быть не ниже 40%, но чем выше, тем лучше.
2. Расчет покрытия будет выполняться скриптом
    ```
    go test -v -coverpkg=./... -coverprofile=coverage.out -covermode=count ./... && go tool cover -func coverage.out | grep total | awk '{print $3}'
    ```

### Архитектура

1. Код должен быть организован согласно [Standard Go Project Layout](https://github.com/golang-standards/project-layout/blob/master/README_ru.md)
2. Остальные архитектурные решения остаются на усмотрение разработчика

### Graceful Shutdown

1. Сервис должен поддерживать `graceful shutdown` при передаче `SIGINT` и `SIGTERM`.
2. Сервис должен логировать полученный сигнал и время, затраченное на остановку. 

### Контейнеризация

1. В репозитории присутствует Dockerfile, позволяющий запустить сервис в docker-контейнере

## Сдача работы и оформление

1. Разместите ваш проект в публичном репозитории на GitHub и отправьте ссылку в Telegram @ryarantsev или @urakov_danil. 
2. Помимо требований, указанных выше, большим плюсом также будут корректно оформленные коммиты: 
   1. Каждый коммит сопровождается кратким описанием внесенных изменений
   2. Каждый коммит фокусируется на строго ограниченном участке функционала 
3. При желании можете настроить пайплайн GitHub Actions с запуском unit-тестов и сессий SAST.

## Полезные ссылки и источники

1. Реализация LRU-кэша без TTL и потокобезопасности (можно использовать эту или подобную реализацию в качестве основы): 
   1. Видео: https://www.youtube.com/watch?v=7ABFKPK2hD4
   2. Код: https://github.com/neetcode-gh/leetcode/blob/main/go/0146-lru-cache.go
2. Документация по chi: https://github.com/go-chi/chi
3. Документация по slog: https://pkg.go.dev/log/slog
4. Документация по env: https://github.com/caarlos0/env
5. Контейнеризация go-приложений: https://docs.docker.com/language/golang/build-images/

## Чеклист для проверки готовности

- [+] LRU-кэш реализован и удовлетворяет описанному интерфейсу
- [+] LRU-кэш потокобезопасен
- [+] LRU-кэш поддерживает удаление данных по TTL
- [+] TTL обновляется при записи данных под уже существующим ключом
- [+] LRU-кэш соответствует требованиям по временной сложности операций
- [+] Реализован обработчик `POST /api/lru`
- [+] Реализован обработчик `GET /api/lru/{key}`
- [+] Реализован обработчик `GET /api/lru`
- [+] Реализован обработчик `DELETE /api/lru/{key}`
- [+] Реализован обработчик `DELETE /api/lru`
- [+] Приложение конфигурируется согласно описанной политике
- [+] Приложение поддерживает все параметры конфигурации (адрес запуска, TTL по умолчанию, размер кэша, уровень логирования)
- [+] Сервис пишет логи
- [+] Каждая запись в лог содержит: уровень логирования, время события, логируемое сообщение
- [+] Сервис логирует каждый входящий запрос: на уровне `DEBUG`, с указанием обработчика, с указанием времени, затраченного на обработку
- [+] Для всех пакетов приложения и всех экспортируемых объектов написана документация в формате `godoc`
- [+] Покрытие кода тестами не ниже 40% (скрипт для расчета покрытия приведен выше)
- [+] Код приложения организован согласно `Standard Go Project Layout`
- [+] Сервис поддерживает `graceful shutdown` в ответ на `SIGINT` и `SIGTERM`
- [+] В репозитории присутствует Dockerfile, позволяющий запустить сервис в docker-контейнере
